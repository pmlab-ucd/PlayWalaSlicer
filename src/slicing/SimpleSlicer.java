/*
Sourced from http://wala.sourceforge.net/wiki/index.php/UserGuide:Slicer
and slightly modified

Original sources can be found at
https://github.com/SCanDroid/WALA/blob/master/com.ibm.wala.core.tests/src/com/ibm/wala/examples/drivers/PDFSlice.java
https://github.com/wala/WALA/blob/master/com.ibm.wala.core.tests/src/com/ibm/wala/examples/drivers/PDFWalaIR.java
*/
package slicing;

import java.io.*;
import java.util.*;
import java.util.jar.JarFile;

import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.classLoader.JarFileModule;
import com.ibm.wala.classLoader.Module;
import com.ibm.wala.ipa.callgraph.CallGraphBuilder;
import com.ibm.wala.ipa.callgraph.impl.Util;
import com.ibm.wala.ipa.callgraph.AnalysisCache;
import com.ibm.wala.ipa.callgraph.AnalysisOptions;
import com.ibm.wala.ipa.callgraph.AnalysisScope;
import com.ibm.wala.ipa.callgraph.CGNode;
import com.ibm.wala.ipa.callgraph.CallGraph;
import com.ibm.wala.ipa.callgraph.Entrypoint;
import com.ibm.wala.ipa.callgraph.propagation.PointerAnalysis;
import com.ibm.wala.ipa.cha.ClassHierarchy;
import com.ibm.wala.ipa.slicer.*;
import com.ibm.wala.ipa.slicer.Slicer.ControlDependenceOptions;
import com.ibm.wala.ipa.slicer.Slicer.DataDependenceOptions;
import com.ibm.wala.ipa.slicer.Statement.Kind;
import com.ibm.wala.properties.WalaProperties;
import com.ibm.wala.ssa.IR;
import com.ibm.wala.ssa.SSAAbstractInvokeInstruction;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.ssa.SSAInvokeInstruction;
import com.ibm.wala.types.ClassLoaderReference;
import com.ibm.wala.types.MethodReference;
import com.ibm.wala.types.TypeReference;
import com.ibm.wala.util.WalaException;
import com.ibm.wala.util.config.AnalysisScopeReader;
import com.ibm.wala.util.debug.Assertions;
import com.ibm.wala.util.graph.Graph;
import com.ibm.wala.util.graph.GraphIntegrity;
import com.ibm.wala.util.graph.GraphSlicer;
import com.ibm.wala.util.graph.GraphUtil;
import com.ibm.wala.util.intset.IntSet;
import com.ibm.wala.util.strings.StringStuff;
import com.ibm.wala.util.collections.Filter;
import com.ibm.wala.viz.DotUtil;
import com.ibm.wala.viz.NodeDecorator;
import com.ibm.wala.viz.PDFViewUtil;

public class SimpleSlicer {

    /**
     * Name of the postscript file generated by dot
     */
    private final static String PDF_FILE = "slice.pdf";

    private static final int PRINT_LIMIT = 10;
    // this is a place where we could cut things down to improve scalability
//    private static File EXCLUSIONS = getExclusionsFile();

    private static final String _androidLib = "./android/android-4.3/android.jar";

    /**
     * Build call graph builder with specific analysis algorithm
     * @param analysis
     * @param options
     * @param cache
     * @param cha
     * @param scope
     * @return
     */
    public static CallGraphBuilder makeCallGraphBuilder(
            String analysis,
            AnalysisOptions options,
            AnalysisCache cache,
            ClassHierarchy cha,
            AnalysisScope scope) {

        CallGraphBuilder builder = null;

        switch(analysis) {
            case "0cfa":
                builder = Util.makeZeroCFABuilder(options, cache, cha, scope, null, null);
                break;
            case "vanilla-1cfa":
                builder = Util.makeVanillaZeroOneCFABuilder(options, cache, cha, scope, null, null);
                break;
            case "container-1cfa":
                builder = Util.makeZeroOneContainerCFABuilder(options, cache, cha, scope);
                break;
            default:
                System.out.println("Unknown analysis");
                System.exit(1);
        }

        return builder;
    }

    /**
     * Run forward slicing
     * @param appJar
     * @param srcCaller
     * @param srcCallee
     * @param analysis
     */
    public static void slice(String appJar, String srcCaller, String srcCallee, String analysis, boolean forward,
                             DataDependenceOptions dataDependenceOptions, ControlDependenceOptions controlDependenceOptions) {
        try {
            // naive timing, but fine for example purposes
            final long startTime = System.currentTimeMillis();

            AnalysisScope scope = AnalysisScopeReader.makeJavaBinaryAnalysisScope(appJar, null); //EXCLUSIONS);
            Module androidMod = new JarFileModule(new JarFile(_androidLib));
            scope.addToScope(ClassLoaderReference.Extension, androidMod);

            // create class hierarchy, wala needs to know the lay of the land
            ClassHierarchy classHierarchy = ClassHierarchy.make(scope);
            CallGraphInfoListener callGraphInfoListener = new CallGraphInfoListener(classHierarchy);
            String manifestPath = "D:\\workspace\\TestSlicer\\app\\test\\AndroidManifest.xml";
            ManifestAnalysis manifestAnalysis = new ManifestAnalysis(manifestPath);
            UIActivityMapping uiActivityAnalysis = new UIActivityMapping(classHierarchy);
            // Look for entrypoints and generate call graph
            EntrypointAnalysis entrypointAnalysis = new EntrypointAnalysis(
                    classHierarchy,
                    manifestAnalysis,
                    uiActivityAnalysis,
                    callGraphInfoListener
            );

            Collection<IMethod> entrypoints = entrypointAnalysis.getEntrypoints();
            CallGraph callGraph = entrypointAnalysis.getCallGraph();

            PointerAnalysis pointerAnalysis = entrypointAnalysis.getPointerAnalysis();

            System.out.println(callGraph.getNumberOfNodes());
            System.out.println(GraphUtil.countEdges(callGraph));

            /*Iterable<Entrypoint> entrypoints = com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope, classHierarchy);
            AnalysisOptions options = new AnalysisOptions(scope, entrypoints);

            // create method references
            MethodReference srcCallerRef = StringStuff.makeMethodReference(srcCaller);
            MethodReference srcCalleeRef = StringStuff.makeMethodReference(srcCallee);

            // build the call graph for entire jar (in reality this would likely be done just for the class)

            CallGraphBuilder builder = makeCallGraphBuilder(analysis, options, new AnalysisCache(), classHierarchy, scope);
            CallGraph cg = builder.makeCallGraph(options, null);*/

            // data and control flow dependencies (for reachability) in slicing

            // find location of first statement that calls srcCallee
            MethodReference srcCallerRef = StringStuff.makeMethodReference(srcCaller);
            MethodReference srcCalleeRef = StringStuff.makeMethodReference(srcCallee);
            CGNode callerNode = findMethod(callGraph, srcCallerRef);
            Statement stmt = findCallTo(callerNode, srcCalleeRef);
            //stmt = getReturnStatementForCall(stmt);

            // collect slice forward
            Collection<Statement> slice = null;
            //PointerAnalysis pa = builder.getPointerAnalysis();
            System.out.println("===> Computing slice");
            if (forward) {
                stmt = getReturnStatementForCall(stmt);
                slice = Slicer.computeForwardSlice(stmt, callGraph, pointerAnalysis, dataDependenceOptions, controlDependenceOptions);
            } else {
                slice = Slicer.computeBackwardSlice(stmt, callGraph, pointerAnalysis, dataDependenceOptions, controlDependenceOptions);
            }
            System.out.println("===> Done with slice");

            // note that the two print statements above are factoring into this time
            final long endTime = System.currentTimeMillis();

            //dumpSlice(slice, PRINT_LIMIT);
            dumpSlice(slice);

            SDG sdg = new SDG(callGraph, pointerAnalysis, dataDependenceOptions, controlDependenceOptions);

            // create a view of the SDG restricted to nodes in the slice
            Graph<Statement> graph = pruneSDG(sdg, slice);

            sanityCheck(slice, graph);

            for (Statement statement : graph) {
                System.out.println(statement);
            }

            report(analysis, endTime - startTime);
            /*
            // load Properties from standard WALA and the WALA examples project
            Properties p = null;
            try {
                p = WalaExamplesProperties.loadProperties();
                p.putAll(WalaProperties.loadProperties());
            } catch (WalaException e) {
                e.printStackTrace();
                Assertions.UNREACHABLE();
            }
            // create a dot representation.
            String psFile = p.getProperty(WalaProperties.OUTPUT_DIR) + File.separatorChar + PDF_FILE;
            String dotExe = p.getProperty(WalaExamplesProperties.DOT_EXE);
            DotUtil.dotify(graph, makeNodeDecorator(), PDFTypeHierarchy.DOT_FILE, psFile, dotExe);

            // fire off the PDF viewer
            String gvExe = p.getProperty(WalaExamplesProperties.PDFVIEW_EXE);


            PDFViewUtil.launchPDFView(psFile, gvExe);*/
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // get exclusions for analysis
    public static File getExclusionsFile() {
        // read file from jar and put it into a temp file
        try {
            InputStream resource =
                    SimpleSlicer.class.getClassLoader().getResourceAsStream("exclusions.txt");
            File tempfile = File.createTempFile("exclusions", ".txt");
            OutputStream out = new FileOutputStream(tempfile);
            int read = 0;
            byte[] data = new byte[1024];

            while((read = resource.read(data)) != -1) {
                out.write(data, 0, read);
            }
            tempfile.deleteOnExit();
            return tempfile;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    // find node for method in call graph
    public static CGNode findMethod(CallGraph cg, MethodReference method) {
        for (Iterator<? extends CGNode> it = cg.iterator(); it.hasNext();) {
            CGNode n = it.next();
            System.out.println(n.getMethod());
            if (n.getMethod().getReference().equals(method)) {
                return n;
            }
        }
        System.err.println("call graph " + cg);
        Assertions.UNREACHABLE("failed to find method " + method.toString());
        return null;
    }

    // modification of original to use method reference
    // find call to method in a particular node in call graph
    public static Statement findCallTo(CGNode n, MethodReference method) {
        IR ir = n.getIR();
        for (Iterator<SSAInstruction> it = ir.iterateAllInstructions(); it.hasNext();) {
            SSAInstruction s = it.next();
            if (s instanceof SSAInvokeInstruction) {
                SSAInvokeInstruction call = (SSAInvokeInstruction) s;
                if (call.getCallSite().getDeclaredTarget().equals(method)) {
                    IntSet indices = ir.getCallInstructionIndices(((SSAInvokeInstruction) s).getCallSite());
                    Assertions.productionAssertion(indices.size() == 1, "expected 1 but got " + indices.size());
                    return new NormalStatement(n, indices.intIterator().next());
                }
            }
        }
        Assertions.UNREACHABLE("failed to find call to " + method.toString() + " in " + n);
        return null;
    }

    // modification of original to use method reference
    // get return statement associated with call
    public static Statement getReturnStatementForCall(Statement s) {
        if (s.getKind() == Kind.NORMAL) {
            NormalStatement n = (NormalStatement) s;
            SSAInstruction st = n.getInstruction();
            if (st instanceof SSAInvokeInstruction) {
                SSAAbstractInvokeInstruction call = (SSAAbstractInvokeInstruction) st;
                if (call.getCallSite().getDeclaredTarget().getReturnType().equals(TypeReference.Void)) {
                    throw new IllegalArgumentException("this driver computes forward slices from the return value of calls.\n" + ""
                            + "Method " + call.getCallSite().getDeclaredTarget().getSignature() + " returns void.");
                }
                return new NormalReturnCaller(s.getNode(), n.getInstructionIndex());
            } else {
                return s;
            }
        } else {
            return s;
        }
    }

    /**
     * Print out statements to stdout (up to limit # of statements)
     * @param slice
     * @param limit
     */
    public static void dumpSlice(Collection<Statement> slice, int limit) {
        Iterator<Statement> s = slice.iterator();
        for (int i = 0; i < limit && s.hasNext(); i++) {
            for (SSAInstruction instruction : s.next().getNode().getIR().getInstructions()) {
                if (instruction != null) {
                    System.out.println(i + ": " + instruction);
                }
            }
        }
    }

    public static void dumpSlice(Collection<Statement> slice, PrintWriter w) {
        w.println("SLICE:\n");
        int i = 1;
        for (Statement s : slice) {
            s.toString();
            String line = (i++) + "   " + s;
            w.println(line);
            w.flush();
        }
    }

    public static void dumpSlice(Collection<Statement> slice) {
        dumpSlice(slice, new PrintWriter(System.err));
    }


    /**
     * check that g is a well-formed graph, and that it contains exactly the number of nodes in the slice
     */
    private static void sanityCheck(Collection<Statement> slice, Graph<Statement> g) {
        try {
            GraphIntegrity.check(g);
        } catch (GraphIntegrity.UnsoundGraphException e1) {
            e1.printStackTrace();
            Assertions.UNREACHABLE();
        }
        Assertions.productionAssertion(g.getNumberOfNodes() == slice.size(), "panic " + g.getNumberOfNodes() + " " + slice.size());
    }


    /**
     * Provide reporting of execution time
     * @param analysis
     * @param ms
     */
    public static void report(String analysis, long ms) {
        System.out.println("\n\t" + analysis + ": " + ms + " ms");
    }

    /**
     * Help message
     */
    public static void help() {
        System.out.println(
                "Usage:java -jar slicer.java slicing.Slicer <target-jar-path> <caller-sig> <callee-sig> <analysis>\n" +
                        "Method signatures should correspond to that found in the bytecode (javap -s)\n" +
                        "Analysis must be one of: 0cfa, vanilla-1cfa, container-1cfa\n" +
                        "For example:\n" +
                        "slicing.Slicer example.jar 'Example.main([Ljava/lang/String;)V;' 'Example.bye(Ljava/lang/String;)Ljava/lang/String;' 0cfa\n"
        );
    }

    /**
     * Run experiment on a given jar + caller + callee + analysis
     * @param args
     */
    public static void main(String[] args) {
        List<String> analysisNames = Arrays.asList("0cfa", "vanilla-1cfa", "container-1cfa");
        if (args.length != 4) {
            help();
            System.exit(1);
        }

        String jarPath = args[0];
        String srcCaller = args[1];
        String srcCallee = args[2];
        String analysis = args[3];

        jarPath = "D:\\workspace\\TestSlicer\\app\\test\\app-debug-dex2jar.jar";
        //jarPath = "D:\\workspace\\TestMallet\\libs\\snowball-20051019.jar";
        srcCaller = "fu.hao.android.testslicer.MainActivity.foo1()V;";
        srcCallee = "android.telephony.TelephonyManager.getDeviceId()Ljava/lang/String;";
        analysis = "0cfa";

        if (!analysisNames.contains(analysis)) {
            help();
            System.exit(1);
        }

        //slice(jarPath, srcCaller, srcCallee, analysis, true);

        srcCaller = "fu.hao.android.testslicer.MainActivity.foo2(Ljava/lang/String;)V;";
        srcCallee = "java.lang.Thread.start()V;";
        slice(jarPath, srcCaller, srcCallee, analysis, false, DataDependenceOptions.NO_HEAP_NO_EXCEPTIONS,
                ControlDependenceOptions.FULL);
    }

    /**
     * return a view of the sdg restricted to the statements in the slice
     */
    public static Graph<Statement> pruneSDG(SDG sdg, final Collection<Statement> slice) {
        Filter<Statement> f = new Filter<Statement>() {
            public boolean accepts(Statement o) {
                return slice.contains(o);
            }
        };
        return GraphSlicer.prune(sdg, f);
    }

    /**
     * @return a NodeDecorator that decorates statements in a slice for a dot-ted representation
     */
    public static NodeDecorator makeNodeDecorator() {
        return new NodeDecorator() {
            public String getLabel(Object o) throws WalaException {
                Statement s = (Statement) o;
                switch (s.getKind()) {
                    case HEAP_PARAM_CALLEE:
                    case HEAP_PARAM_CALLER:
                    case HEAP_RET_CALLEE:
                    case HEAP_RET_CALLER:
                        HeapStatement h = (HeapStatement) s;
                        return s.getKind() + "\\n" + h.getNode() + "\\n" + h.getLocation();
                    case NORMAL:
                        NormalStatement n = (NormalStatement) s;
                        return n.getInstruction() + "\\n" + n.getNode().getMethod().getSignature();
                    case PARAM_CALLEE:
                        ParamCallee paramCallee = (ParamCallee) s;
                        return s.getKind() + " " + paramCallee.getValueNumber() + "\\n" + s.getNode().getMethod().getName();
                    case PARAM_CALLER:
                        ParamCaller paramCaller = (ParamCaller) s;
                        return s.getKind() + " " + paramCaller.getValueNumber() + "\\n" + s.getNode().getMethod().getName() + "\\n"
                                + paramCaller.getInstruction().getCallSite().getDeclaredTarget().getName();
                    case EXC_RET_CALLEE:
                    case EXC_RET_CALLER:
                    case NORMAL_RET_CALLEE:
                    case NORMAL_RET_CALLER:
                    case PHI:
                    default:
                        return s.toString();
                }
            }
        };
    }
}